/*************************************************
 * Publicly released by Rhoban System, August 2012
 *             www.rhoban-system.fr
 *
 * Freely usable for non-commercial purposes
 *
 * Licence Creative Commons *CC BY-NC-SA
 * http://creativecommons.org/licenses/by-nc-sa/3.0
 *************************************************/
/*****************************************************************************
 * TickMachine.cpp
 *
 *  Created on: 19 juil. 2011
 *      Author: hugo
 *****************************************************************************/
#include <sys/time.h>
#include <iostream>
#include <math.h>
#include <stdio.h>
#ifdef WIN32
#include <windows.h>
#endif
#include "util.h"
#include "ticks.h"
#include "TickMachine.h"
using namespace std;
/*****************************************************************************/

TickMachine * TickMachine::the_tick_machine = NULL;

timeval TickMachine::start_time;

TickMachine * TickMachine::get_tick_machine() {
	//todo: return only when tick machine is started
	if (TickMachine::the_tick_machine != NULL) return TickMachine::the_tick_machine;
	TickMachine::the_tick_machine = TickMachine::createTickMachine();
	return TickMachine::the_tick_machine;
};

void TickMachine::init_tick_machine() {
	TickMachine::get_tick_machine();
}

TickMachine * TickMachine::createTickMachine()
{
	TickMachine * new_tick_machine;
	gettimeofday(&start_time,0);

#ifndef WIN32
	//blocks the alarm signal for the calling thread
	//otherwise the thread would be immediately killed by
	//the unblocked alarm signals generated by the tick machine
	Thread::block_signal(SIGALRM);
#endif

	TM_DEBUG_MSG("Tick machine creating...");
	new_tick_machine = new TickMachine();
	TM_DEBUG_MSG("Tick machine created and starting...");
	new_tick_machine->start(0);
	TM_DEBUG_MSG("Tick machine started and resuming...");
	new_tick_machine->resume_thread();
	TM_DEBUG_MSG("Tick machine launched.");
	return new_tick_machine;
}

TickMachine::TickMachine() : timer_to_dispose(false), timer_to_register(false), timer_to_unregister(false)
{
	timer_should_be_updated = false;
	granularity_should_be_updated  = false;
	granularity.tv_sec = 0;
	granularity.tv_usec = (int) (1000000 / min_frequency);
}


void TickMachine::register_timer(TickTimer * timer)
{
	/*
	if(timer->timer_name == "")
	{
		int i = 0;
	}
	 */
	//section critique
	TM_CAUTION_MSG("Registering timer '" << timer->timer_name << "' (" << (long long int) timer << ") with frequency " << timer->get_frequency() << "Hz ...");

	if(!timer)
	{
		TM_DEBUG_MSG("Null timer!");
		return;
	}

	if(currentThreadId() != threadId())
	{
		timer->started.lock();
		timers_to_register_list_mutex.lock();
	}

	timers_to_register.push_back(timer);
	timer_to_register = true;

	if(currentThreadId() != threadId())
	{
		timers_to_register_list_mutex.unlock();
		timer->started.wait(5000);
		timer->started.unlock();
	}

}

void TickMachine::unregister_timer(TickTimer * timer)
{
	TM_DEBUG_MSG("Unregistering timer '" << timer_name << "'" << (long long int) timer);

	if(currentThreadId() != threadId())
	{
		timer->unregistered.lock();
		timers_to_register_list_mutex.lock();
		timers_to_unregister_list_mutex.lock();
	}

	for(list<TickTimer *>::iterator it = timers_to_register.begin(); it != timers_to_register.end(); it++)
		if(*it == timer)
		{
			timers_to_register.erase(it);
			break;
		}

	timers_to_unregister.push_back(timer);
	timer_to_unregister = true;

	if(currentThreadId() != threadId())
	{
		timers_to_unregister_list_mutex.unlock();
		timers_to_register_list_mutex.unlock();
		timer->unregistered.wait(5000);
		timer->unregistered.unlock();
	}
}


/*! \brief to delete when the timer is no longer used */
void TickMachine::dispose_timer(TickTimer ** timer)
{
	TM_CAUTION_MSG("Disposing timer " << (*timer)->timer_name);

	if(currentThreadId() != threadId())
	{
		timers_to_register_list_mutex.lock();
		timers_to_delete_list_mutex.lock();
	}

	for(list<TickTimer *>::iterator it = timers_to_register.begin(); it != timers_to_register.end(); it++)
		if(*it == *timer)
		{
			timers_to_register.erase(it);
			break;
		}

	timers_to_delete.push_back(*timer);
	timer_to_dispose = true;

	if(currentThreadId() != threadId())
	{
		timers_to_register_list_mutex.unlock();
		timers_to_delete_list_mutex.unlock();
	}
	timer = 0;
}



TickMachine::~TickMachine()
{

}

void TickMachine::set_granularity(struct timeval musec)
{
	TM_DEBUG_MSG("set_granularity");
	granularity = musec;
	for (list<TickTimer *>::iterator timer_ = players.begin();timer_ != players.end();timer_++)
		(*timer_)->set_relative(granularity);
	timer_should_be_updated = true;
	TM_DEBUG_MSG("TickMachine time grain is "<< to_secs(musec) << " secs");
}

void TickMachine::update_timer()
{
	timer_should_be_updated = false;
	TM_DEBUG_MSG("Updating timer with granularity "<< to_secs(granularity));
#ifdef WIN32
#else
	/*
	 * Set the real time interval timer
	 */
	struct itimerval value;
	value.it_interval = granularity;
	value.it_value = granularity;

	/*protects from signal*/
	block_signal(SIGALRM);

	/*set timer to throw periodic alaram signals*/
	int res = setitimer( ITIMER_REAL, &value, NULL );
	if(res==-1)
	{
		perror("Could not setitimer");
		throw string("Could not setitimer");
	}
	/*	else
        {
        struct itimerval res;
        getitimer( ITIMER_REAL, &res);
        cout << "Ittimer set to next value "<< res.it_interval.tv_sec << "sec " << res.it_interval.tv_usec<<endl;
        cout << "Ittimer set to current value "<< res.it_value.tv_sec << "sec " << res.it_value.tv_usec<<endl;
        }*/
#endif
}


/*!
 * main loop of the tick machine
 */
void TickMachine::execute()
{
	TM_DEBUG_MSG("Waiting for first resume");
	wait_for_resume();
	TM_DEBUG_MSG("Starting Loop !");
	while(true)
	{

		if(timer_to_dispose)
		{
			timer_to_dispose = false;
			BEGIN_SAFE(timers_to_delete_list_mutex)
			TM_CAUTION_MSG("Asynchronously deleting " << timers_to_register.size() << "timers");
			for(list<TickTimer *>::iterator pt = timers_to_delete.begin(); pt!= timers_to_delete.end(); pt++)
			{
				TickTimer * timer = *pt;
				try
				{
					TM_DEBUG_MSG("Unregistering timer '" << timer->timer_name << "' (" << (long long int) timer << ")");
					players.remove(timer);
					delete timer;
					timer->disposed.broadcast();
				}
				catch(string & exc)
				{
					TM_CAUTION_MSG("Failed to delete timer: exc")
				}
			}
			timers_to_delete.clear();
			END_SAFE(timers_to_delete_list_mutex)
			granularity_should_be_updated = true;
		}

		/* Timers are typically unregistered then destroyed thus no external thread should unregister a timer while step a timer */
		BEGIN_SAFE(timers_to_unregister_list_mutex)

		if(timer_to_register)
		{
			timer_to_register = false;
			BEGIN_SAFE(timers_to_register_list_mutex)
			TM_CAUTION_MSG("Asynchronously registering " << timers_to_register.size() << " timers");
			for(list<TickTimer *>::iterator pt = timers_to_register.begin(); pt!= timers_to_register.end(); pt++)
			{
				TickTimer * timer = *pt;
				TM_CAUTION_MSG("Registering new timer '" << timer->timer_name << "' (" << (long long int) timer << ")");
				try
				{
					gettimeofday(&timer->start_time,0);
					timer->tick();
					players.push_back(timer);
					timer->started.broadcast();
					TM_DEBUG_MSG("Registered timer with frequency " << timer->get_frequency() << "Hz ...")
				}
				catch(string & exc)
				{
					TM_CAUTION_MSG("Failed to register timer: exc")
				}
			}
			timers_to_register.clear();
			END_SAFE(timers_to_register_list_mutex)
			granularity_should_be_updated = true;
		}

		if(timer_to_unregister)
		{
			timer_to_unregister = false;
			TM_CAUTION_MSG("Asynchronously unregistering " << timers_to_register.size() << " timers");
			for(list<TickTimer *>::iterator pt = timers_to_unregister.begin(); pt!= timers_to_unregister.end(); pt++)
			{
				TickTimer * timer = *pt;
				try
				{
					players.remove(timer);
					timer->unregistered.broadcast();
				}
				catch(string & exc)
				{
					TM_CAUTION_MSG("Failed to unregister timer: " << exc)
				}
			}
			timers_to_unregister.clear();
			granularity_should_be_updated = true;
		}

		granularity_mutex.lock();
		if(granularity_should_be_updated)
		{
			update_granularity_and_players();
			granularity_should_be_updated = false;
		}

		granularity_mutex.unlock();

		if(timer_should_be_updated)
			update_timer();

		tick_players();
		END_SAFE(timers_to_unregister_list_mutex)

#ifdef WIN32
		Sleep( (granularity.tv_sec*1000+granularity.tv_usec/1000) / 5);
#else
		wait_signal(SIGALRM);
#endif
	}
}


/*! \brief alert the tick machien to change granularity */
void TickMachine::FrequencyChanged()
{
	TickMachine * the = TickMachine::get_tick_machine();

	if(the->threadId() != Thread::currentThreadId())
		the->granularity_mutex.lock();
	TM_CAUTION_MSG("TM Freq shoud be updated ");
	the->granularity_should_be_updated = true;
	if(the->threadId() != Thread::currentThreadId())
		the->granularity_mutex.unlock();
}

void TickMachine::tick_players()
{
	timeval now;
	gettimeofday(&now,0);

	TM_DEBUG_MSG(players.size()<<" players to tick");
	for (list<TickTimer *>::iterator timer_ = players.begin();timer_ != players.end();timer_++)
	{
		TickTimer * timer = *timer_;
		/* Tricky case: a timer has been unregistered (hence probably deleted) by a timer before in the same tm round
		 * In this case it should be skipped
		 */
		for(list<TickTimer *>::iterator tt = timers_to_unregister.begin(); tt != timers_to_unregister.end(); tt++)
			if(*tt == timer)
				continue;

#ifndef WIN32
		if(timer->relative > 0)
			if(--(timer->tick_counter) <= 0)
				timer->tick();
#else
		//We cannot trust tick counter because we dont have a precise timing signal like SIGALARM is (to be checked)
		TM_DEBUG_MSG("Cheking whether timer " << (long long int) timer << " is tickable");
		if(timer->is_tickable(now))
		{
			TM_DEBUG_MSG("Ticking timer " << (long long int) timer << " at " << timer->frequency);
			timer->tick();
		}
		else
		{
			timeval now;
			gettimeofday(&now, NULL);
			TM_DEBUG_MSG("Skipping timer " << (long long int) timer << " with diff counter " << (to_secs(now ) - to_secs(timer->start_time) ) * timer->frequency << " " << timer->ticks_elapsed);
		}
#endif
	}

	/* old version, more precise but too heavy and useless
       if(is_after(now, (*player_)->next_tick_date))
    //			(*player_)->tick(now);
    {
    cout << "Unskipped: frequency "<< (*player_)->frequency << " interval " << to_secs((*player_)->tick_interval) <<" overhead " <<  to_secs(now) - to_secs((*player_)->next_tick_date)<<endl;
    (*player_)->tick(now);
    }
    else
    cout << "Skipped: frequency "<< (*player_)->frequency << " interval " << to_secs((*player_)->tick_interval) << " to go " <<  to_secs((*player_)->next_tick_date) - to_secs(now)<<endl;
	 */
}
/*!
 * updates time granularity of the machine,
 * according to the frequencies of players
 */
void TickMachine::update_granularity_and_players(double max_relative_error)
{
	TM_DEBUG_MSG("update_granularity_and_players");

	//default granularity is min frequency
	double gran = 1.0/ min_frequency;

	//computes the target granularity
	for (list<TickTimer *>::iterator timer_ = players.begin();timer_ != players.end();timer_++)
	{
		gran = min(gran, 1.0 / (*timer_)->get_frequency());
	}

	struct timeval new_gran;
	new_gran.tv_sec = static_cast<int>(floor(gran));
	new_gran.tv_usec = static_cast<int>(1000000*(gran-new_gran.tv_sec));

	//sets the new values for the timer
	set_granularity(new_gran);
	TM_DEBUG_MSG("Done update_granularity_and_players");


}

