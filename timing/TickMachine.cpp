/*************************************************
 * Publicly released by Rhoban System, August 2012
 *             www.rhoban-system.fr
 *
 * Freely usable for non-commercial purposes
 *
 * Licence Creative Commons *CC BY-NC-SA
 * http://creativecommons.org/licenses/by-nc-sa/3.0
 *************************************************/
/*****************************************************************************
 * TickMachine.cpp
 *
 *  Created on: 19 juil. 2011
 *      Author: hugo
 *****************************************************************************/
#include <sys/time.h>
#include <iostream>
#include <math.h>
#include <stdio.h>
#ifdef WIN32
#include <windows.h>
#endif
#include "util.h"
#include "ticks.h"
#include "TickMachine.h"
using namespace std;
/*****************************************************************************/

TickMachine * TickMachine::the_tick_machine = NULL;

timeval TickMachine::start_time;

TickMachine * TickMachine::get_tick_machine() {
    if (TickMachine::the_tick_machine != NULL) return TickMachine::the_tick_machine;
    TickMachine::the_tick_machine = TickMachine::createTickMachine();
    return TickMachine::the_tick_machine;
};

void TickMachine::init_tick_machine() {
    TickMachine::get_tick_machine();
}

TickMachine * TickMachine::createTickMachine()
{
    TickMachine * new_tick_machine;
    gettimeofday(&start_time,0);

#ifndef WIN32
    //blocks the alarm signal for the calling thread
    //otherwise the thread would be immediately killed by
    //the unblocked alarm signals generated by the tick machine
    Thread::block_signal(SIGALRM);
#endif

    TM_DEBUG_MSG("Tick machine creating...");
    new_tick_machine = new TickMachine();
    TM_DEBUG_MSG("Tick machine created and starting...");
    new_tick_machine->start(0);
    TM_DEBUG_MSG("Tick machine started and resuming...");
    new_tick_machine->resume_thread();
    TM_DEBUG_MSG("Tick machine launched.");
    return new_tick_machine;
}

TickMachine::TickMachine() : to_kill(0)
{
	BEGIN_SAFE(safe)
    timer_should_be_updated = false;
    granularity.tv_sec = 0;
    granularity.tv_usec = (int) (1000000 / min_frequency);
	END_SAFE(safe)
}

/*****************************************************************************/
/*! \brief To be called by a timed thread. the tick machine creates a mutex timer that
 * will tick at the given frequency. Use timer->wait_next_tick() to wait between two ticks*/
void TickMachine::register_timer(TickTimer * timer, double hertz)
{
    if(!timer || !hertz)
    {
        TM_DEBUG_MSG("Null timer!");
        return;
    }
    TickMachine::get_tick_machine()->internal_register_timer(timer);
}

/*! \brief to clean up when a timed mutex is no longer used */
void TickMachine::unregister_timer(TickTimer * timer)
{
    TickMachine::get_tick_machine()->internal_unregister_timer(timer);
}


void TickMachine::internal_register_timer(TickTimer * timer)
{
    //section critique
    TM_DEBUG_MSG("registering timer " << (long long int) timer << " with frequency " << timer->get_frequency() << "Hz ...")

	BEGIN_SAFE(safe)
    TM_DEBUG_MSG("safe locked");
    players.push_back(timer);
    TM_DEBUG_MSG("pushed new timer " << (long long int) timer);
    update_granularity_and_players();
    TM_DEBUG_MSG("updated granularity ");
    timer->set_relative();
    TM_DEBUG_MSG("set relative of new timer ");
    END_SAFE(safe)

    TM_DEBUG_MSG("Done with registering timer with frequency " << timer->get_frequency() << "Hz ...")

    gettimeofday(&timer->start_time,0);

    timer->tick();

    /*
       timeval now;
       gettimeofday(&now,0);
       decrease(now,timer->start_time);
       TM_DEBUG_MSG("... timer registered in "<< to_secs(now)<< "secs");
    //fin sectiion critique
    */
}

void TickMachine::internal_unregister_timer(TickTimer * timer)
{

    if(!timer) {
        TM_CAUTION_MSG ("Tryng to destroy timer NULL");
        throw string("Trying to destroy timer NULL");
    }
    else
        TM_DEBUG_MSG("Unregistering timer");

    /* Awaits for the tick machine to be ready */
    wait_started();

    TM_DEBUG_MSG("Locking");
    BEGIN_SAFE(safe)
    TM_DEBUG_MSG("Removing player from list");
    players.remove(timer);
    update_granularity_and_players();
    END_SAFE(safe)
    TM_DEBUG_MSG("Timer unregistered");
}

void TickMachine::change_frequency(TickTimer * timer, double hertz) {
    TickMachine::get_tick_machine()->internal_change_frequency(timer, hertz);
}

void TickMachine::internal_change_frequency(TickTimer * timer, double hertz)
{
    if(!timer) {
        TM_CAUTION_MSG ("Tryng to change frequency of null timer");
        return;
    }
    else {
        TM_DEBUG_MSG("Changing frequency of timer " << (long long int) timer << " to " << hertz);
    }


    /* Awaits for the tick machine to be ready */
    wait_started();

    TM_DEBUG_MSG("Internal change frequency changed to " << hertz);

    BEGIN_SAFE(safe)
    update_granularity_and_players();
    END_SAFE(safe)

    TM_DEBUG_MSG("Frequency changed " << hertz);

}

TickMachine::~TickMachine()
{

}

void TickMachine::set_granularity(struct timeval musec)
{
    TM_DEBUG_MSG("set_granularity");
    granularity = musec;
    for (list<TickTimer *>::iterator timer_ = players.begin();timer_ != players.end();timer_++)
        (*timer_)->set_relative();
    timer_should_be_updated = true;
    TM_DEBUG_MSG("TickMachine time grain is "<< to_secs(musec) << " secs");
}

void TickMachine::update_timer()
{
    timer_should_be_updated = false;
    TM_DEBUG_MSG("Updating timer with granularity "<< to_secs(granularity));
#ifdef WIN32
#else
    /*
     * Set the real time interval timer
     */
    struct itimerval value;
    value.it_interval = granularity;
    value.it_value = granularity;

    /*protects from signal*/
    block_signal(SIGALRM);

    /*set timer to throw periodic alaram signals*/
    int res = setitimer( ITIMER_REAL, &value, NULL );
    if(res==-1)
    {
        perror("Could not setitimer");
        throw string("Could not setitimer");
    }
    /*	else
        {
        struct itimerval res;
        getitimer( ITIMER_REAL, &res);
        cout << "Ittimer set to next value "<< res.it_interval.tv_sec << "sec " << res.it_interval.tv_usec<<endl;
        cout << "Ittimer set to current value "<< res.it_value.tv_sec << "sec " << res.it_value.tv_usec<<endl;
        }*/
#endif
}


//return the time actually elapsed
void TickMachine::wait_next_tick()
{
#ifdef WIN32
    Sleep( (granularity.tv_sec*1000+granularity.tv_usec/1000) / 5);
#else
    wait_signal(SIGALRM);
#endif
}


/*!
 * main loop of the tick machine
 */
void TickMachine::execute()
{
    TM_DEBUG_MSG("Waiting for first resume");
    wait_for_resume();
    TM_DEBUG_MSG("Starting Loop !");
    while(true)
    {
        TM_DEBUG_MSG("Ticking machine 1");
    	BEGIN_SAFE(safe)
        if(timer_should_be_updated)
            update_timer();
        TM_DEBUG_MSG("Ticking machine 2");
        tick_players();
        END_SAFE(safe)
        TM_DEBUG_MSG("Ticking machine 3");

        //we do not want to kill the timer while scanning the list of timers
        if(to_kill)
        {
            TM_DEBUG_MSG("Killing timer...");
            cout << "Killing timer..." << endl;
            if(to_kill->use_locks && to_kill->ticks_elapsed % 2)
                to_kill->odd.unlock();
            else
            	to_kill->even.unlock();
            delete to_kill;
            to_kill = 0;
            TM_DEBUG_MSG("timer killed...");
        }
        TM_DEBUG_MSG("Ticking machine 4");

        wait_next_tick();
        TM_DEBUG_MSG("Ticking machine 5");

    }
}

void TickMachine::tick_players()
{
	timeval now;
	gettimeofday(&now,0);

    TM_DEBUG_MSG(players.size()<<" players to tick");
    for (list<TickTimer *>::iterator timer_ = players.begin();timer_ != players.end();timer_++)
    {
        TickTimer * timer = *timer_;
        if(timer->tm_kill_me)
        {
            //we do not want to kill the timer while scanning the list of timers,
            //so postpone it to after the loop
            TM_DEBUG_MSG("Marking timer to be killed");
            to_kill = timer;
        }
        else
        {
#ifndef WIN32
        	if(timer->relative > 0 && --(timer->tick_counter) <= 0)
        		timer->tick();
#else
        	//We cannot trust tick counter because we dont have a precise timing signal like SIGALARM is (to be checked)
    		TM_DEBUG_MSG("Cheking whether timer " << (long long int) timer << " is tickable");
        	if(timer->is_tickable(now))
        	{
        		TM_DEBUG_MSG("Ticking timer " << (long long int) timer << " at " << timer->frequency);
        		timer->tick();
        	}
        	else
        	{
        		timeval now;
        		gettimeofday(&now, NULL);
        		TM_DEBUG_MSG("Skipping timer " << (long long int) timer << " with diff counter " << (to_secs(now ) - to_secs(timer->start_time) ) * timer->frequency << " " << timer->ticks_elapsed);
        	}
#endif
        }
    }

    /* old version, more precise but too heavy and useless
       if(is_after(now, (*player_)->next_tick_date))
    //			(*player_)->tick(now);
    {
    cout << "Unskipped: frequency "<< (*player_)->frequency << " interval " << to_secs((*player_)->tick_interval) <<" overhead " <<  to_secs(now) - to_secs((*player_)->next_tick_date)<<endl;
    (*player_)->tick(now);
    }
    else
    cout << "Skipped: frequency "<< (*player_)->frequency << " interval " << to_secs((*player_)->tick_interval) << " to go " <<  to_secs((*player_)->next_tick_date) - to_secs(now)<<endl;
    */
}
/*!
 * updates time granularity of the machine,
 * according to the frequencies of players
 */
void TickMachine::update_granularity_and_players(double max_relative_error)
{
    TM_DEBUG_MSG("update_granularity_and_players");

    //default granularity is min frequency
    double gran = 1.0/ min_frequency;

    //computes the target granularity
    for (list<TickTimer *>::iterator timer_ = players.begin();timer_ != players.end();timer_++)
    {
        gran = min(gran, 1.0 / (*timer_)->get_frequency());
    }

    struct timeval new_gran;
    new_gran.tv_sec = static_cast<int>(floor(gran));
    new_gran.tv_usec = static_cast<int>(1000000*(gran-new_gran.tv_sec));

    //sets the new values for the timer
    set_granularity(new_gran);
    TM_DEBUG_MSG("Done update_granularity_and_players");

}

